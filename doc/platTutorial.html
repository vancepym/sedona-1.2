<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

<!--

  Copyright (c) 2009 Tridium, Inc
  Licensed under the Academic Free License version 3.0

  History:
    07 Jan 2010 - Matthew Giannini creation

-->

<!-- TOC-HEADER-START -->
<!-- Auto-generated by sedonac -->
<head>
  <title>Platform Tutorial</title>
  <meta http-equiv='Content-type' content='text/html;charset=UTF-8' />
  <link rel='stylesheet' type='text/css' href='style.css'/>
</head>
<body>
<p>
  <a href='index.html'>
    <img src='logo.png' alt='Sedona'/>
  </a>
</p>
<div class='nav'>
  <a href='index.html'>Index</a>
 | <a href='par.html'>Prev</a>
 | <a href='platCertified.html'>Next</a>
</div>
<h1 class='title'>Platform Tutorial</h1>
<div class='content'>
<!-- TOC-HEADER-END -->

<p>A Sedona Framework platform is simply any device running an SVM. The platform is
uniquely identified by the <b><i>platformId</i></b> property of the platform
service running in the app on that device.</p>

<p>This section presents a high-level, step-by-step guide to creating a Sedona Framework platform
for your own device. We will use the Win32 platform provided in the open source
distribution as a case study in creating a new Sedona Framework platform.</p>

<ol>
  <li><a href="#step1">Step 1: </a>Create a kit for your platform service</li>
  <li><a href="#step2">Step 2: </a>Create a platform definition file</li>
  <li><a href="#step3">Step 3: </a>Port the SVM</li>
  <li><a href="#step4">Step 4: </a>Build the SVM</li>
  <li><a href="#step5">Step 5: </a>Create a PAR file</li>
  <li><a href="#step6">Step 6: </a>SAX and Scode setup for your platform</li>
</ol>

<!--/////////////////////////////////////////////////////////-->
<h1 id="step1">Step 1: Create a kit for your platform service</h1>
<!--/////////////////////////////////////////////////////////-->

<p>Every app must have a <code>sys::PlatformService</code> component
running in it. A platform service encapsulates the behavior of that 
specific OS/Hardware platform. 
</p>

<p>
The first step in porting Sedona to a new platform is the creation of
a PlatformService subclass for the platform.
As an example, the win32 platform service is defined in a kit called "platWin32" and
the kit definition file is in 
<code><i>sedona_home</i>/platforms/src/generic/win32/kit.xml</code>
</p>

<p>
The base class <code>sys::PlatformService</code> defines three native methods 
that must be implemented for every platform.  
They are called by <code>PlatformService</code> as needed to populate
the corresponding properties.
</p>

<ul>
<li><code>doPlatformId()</code>: returns platform ID string</li>
<li><code>getPlatVersion()</code>: returns platform version string</li>
<li><code>getNativeMemAvailable()t</code>: returns number of bytes of physical memory available</li>
</ul>

<p>
The open source includes win32 natives as an example, see
<code><i>sedona_home </i>/src/sys/native/win32</code>.
</p>

<p id="doPlatformId">
One of the most important properties on the platform
service is the <code>platformId</code> property. This property uniquely
identifies your platform, and should map to a platform stored in the
platform database.
The native implementation of <code>doPlatformId()</code>
for our win32 platform is
</p>

<pre>
#include "sedona.h"
#include "sedonaPlatform.h"
#include &lt;windows.h>

// Str PlatformService.doPlatformId()
Cell sys_PlatformService_doPlatformId(SedonaVM* vm, Cell* params)
{
  Cell result;
  result.aval = PLATFORM_ID;
  return result;
}
</pre>

<p>
Notice that our native implementation makes use of the <code>sedonaPlatform.h</code>
header file that was generated based on our platform definition XML file. The
benefit of this approach is that we can dynamically change the implementation of
the underlying SVM without having to create distinct platform services for all
those unique configurations. The next step describes how to create the
platform definition for our win32 platform.
</p>


<!--/////////////////////////////////////////////////////////-->
<h1 id="step2">Step 2: Create a platform definition XML file</h1>
<!--/////////////////////////////////////////////////////////-->

<p>Please refer to the section on <a href="platDef.html">platform definition</a>
for an in depth discussion of this file.</p>

<p> The platform definition for the win32 platform is located in
<code><i>sedona_home</i>/platforms/src/generic/win32/generic-win32.xml</code>.</p>

<pre>
&lt;sedonaPlatform vendor="Tridium" id="tridium-generic-win32-${sedona.env.version}" >

  &lt;compile endian="little" blockSize="4" refSize="4" debug="true" test="true">

    &lt;!-- Native Kits -->
    &lt;nativeKit depend="sys 1.0" />
    &lt;nativeKit depend="inet 1.0" />
    &lt;nativeKit depend="datetimeStd 1.0" />
    &lt;nativeKit depend="platWin32 1.0" />

    &lt;!-- Native Sources -->
    &lt;nativeSource path="/src/vm" />
    &lt;nativeSource path="/src/sys/native" />
    &lt;nativeSource path="/src/sys/native/std" />
    &lt;nativeSource path="/src/sys/native/win32" />
    &lt;nativeSource path="/src/inet/native" />
    &lt;nativeSource path="/src/inet/native/std" />
    &lt;nativeSource path="/src/inet/native/sha1" />
    &lt;nativeSource path="/src/datetimeStd/native/std" />
    &lt;nativeSource path="/platforms/src/generic/win32/native" />
  &lt;/compile>

&lt;/sedonaPlatform>
</pre>

<p>There are a few things to note about our platform definition.</p>

<ol>
  <li>We have specified the <code>id</code> attribute for our platform. Later, when we
  run sedonac on this file to stage the source, we can expect the <code>sedonaPlatform.h</code>
  header file to be generated. This is what our <a href="#doPlatformId">doPlatformId()</a> native
  code used to set the platform id.
  </li>
  <li>Our SVM will only be able to support the native methods from
  the sys, inet, datetimeStd, and platWin32 kits because of our <code>&lt;nativeKit></code> declarations.</li>
</ol>

<!--/////////////////////////////////////////////////////////-->
<h1 id="step3">Step 3: Port the SVM</h1>
<!--/////////////////////////////////////////////////////////-->

<p>This process is already described in detail in the <a href="porting.html">porting</a>
section. We specified in our platform definition where all the native source
code would be located for our SVM. Typically, as we are porting the SVM we will
need to update our platform definition so that it references all the correct
locations for the native code in the <code>&lt;nativeSource></code> directives.</p>

<p>Refer to the platform definition for our win32 platform to see where all the
native code for SVM resides and how it was implemented.</p>

<!--/////////////////////////////////////////////////////////-->
<h1 id="step4">Step 4: Build the SVM</h1>
<!--/////////////////////////////////////////////////////////-->

<p>As we are porting our SVM, we will want to periodically build it so that
we can test it. As described in the <a href="porting.html#staging">staging</a>
section, we can use <code>sedonac</code> to stage all native source files in one
directory. Then we must develop our own build scripts (native tool-chain) to
actually build the SVM.</p>

<p>The open source distribution includes a <code>makewinvm.py</code> script
that will build our win32 platform SVM. It will run <code>sedonac</code> on our
generic-win32.xml platform definition file to stage all the source code for the
SVM, and then it will compile the source code into a binary. This is the svm.exe
that you will find in the bin/ directory of the open source distribution. To run
this script you must have <a href="setup.html">setup</a> your environment for
development.</p>

<p>You must provide your own native tool-chain to accomplish the same tasks
for your platform.</p>

<!--/////////////////////////////////////////////////////////-->
<h1 id="step5">Step 5: Create a PAR file for your platform</h1>
<!--/////////////////////////////////////////////////////////-->

<p>Refer to the section on <a href="par.html">PAR files</a> for a more in-depth
discussion on PAR files.</p>

<p>When we staged our native source by running <code>sedonac</code> on our
platform definition, it also staged a <code>.par/</code> directory for us. Since
we specified a platform id attribute in our platform definition, the platformManifest.xml
in that directory is valid.  Therefore, all we need to do is zip up the contents
of that directory and use the platformdb.py script to install it in our platform database.</p>

<p>The <code>makewinvm.py</code> script does this for the open source win32 platform. If
you issue the <code>platformdb.py --list</code> command you should see output similar
to the following</p>

<pre>
D:\sedona\baseline\pub>platformdb.py --list
tridium-generic-win32-1.0.46
</pre>

<p>This output indicates that the we have successfully installed our win32 platform
into the platform database.  You will need to make it part of the native tool-chain
for your platform to create the PAR file and install it into the platform database. You
can use the <code>platformdb -i &lt;par file></code> command to install a PAR file
into the platform database.</p>

<!--/////////////////////////////////////////////////////////-->
<h1 id="step6">Step 6: SAX and Scode setup for your platform</h1>
<!--/////////////////////////////////////////////////////////-->

<p>To use your new platform service, you will need to create an application
(SAX) that uses your platform service. There is an example SAX file that uses
the Win32PlatformService at <code><i>sedona_home</i>/apps/platWin32.sax</code>.
You can use this file as a template and make the following modifications to use your
platforms service:</p>
<ol>
<li>In the <code>&lt;schema></code> section, remove the platWin32 kit and add the kit
for your platform service.</li>
<li>In the <code>&lt;app></code> section there is a component called "plat".
Change the type of that component from "platWin32::Win32PlatformService" to the
type of your platform service.</li>
</ol>

<p>After you have made these changes you can run sedonac on your new SAX file
to create an binary application (SAB) that your SVM can run.</p>

<p>
Finally, you will need to create a scode image corresponding to the kits in your
SAX.  There is an example scode configuration file in <code><i>sedona_homde</i>/scode/platWin32.xml</code>.
You can use this file as a template and make the following modification for your
platform:</p>

<ol>
<li>Modify the <code>&lt;sedonaCode></code> elements to match the settings
for your device. For example, make sure the blockSize, refSize, endian, etc.
are correct.</li>
<li>Remove the dependency on the "platWin32 1.0" and add a dependency for the
kit containing your platform service.</li>
</ol>

<p>After you have made these changes you an run sedonac on your new scode xml
file to produce an scode image that your SVM can run.</p>

<!-- TOC-FOOTER-START -->
<!-- Auto-generated by sedonac -->
</div>
<div class='nav'>
  <a href='index.html'>Index</a>
 | <a href='par.html'>Prev</a>
 | <a href='platCertified.html'>Next</a>
</div>
<div class='copyright'><script type='text/javascript'>document.write("Copyright &#169; " + new Date().getFullYear() + " Tridium, Inc.")</script></div>
</body>
<!-- TOC-FOOTER-END -->

</html>







