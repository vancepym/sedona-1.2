<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

<!--

  Copyright (c) 2007 Tridium, Inc
  Licensed under the Academic Free License version 3.0

  History:
    17 May 07  Brian Frank  Creation

-->

<!-- TOC-HEADER-START -->
<!-- Auto-generated by sedonac -->
<head>
  <title>Schema</title>
  <meta http-equiv='Content-type' content='text/html;charset=UTF-8' />
  <link rel='stylesheet' type='text/css' href='style.css'/>
</head>
<body>
<p>
  <a href='index.html'>
    <img src='logo.png' alt='Sedona'/>
  </a>
</p>
<div class='nav'>
  <a href='index.html'>Index</a>
 | <a href='kits.html'>Prev</a>
 | <a href='platDef.html'>Next</a>
</div>
<h1 class='title'>Schema</h1>
<div class='content'>
<!-- TOC-HEADER-END -->

<!-- /////////////////////////////////////////////////////// -->
<h1 id="overview">Overview</h1>
<!-- /////////////////////////////////////////////////////// -->

<p>
Because the Sedona Framework is designed to work in very constrained embedded
environments, we have to make design tradeoffs.  One of the biggest
tradeoffs is using a low level binary format for Sedona Framework application
files and the Sox protocol.  These binary formats require out-of-band
information for encoding and decoding.  For example the binary formats
assume you know how kit, type, and slot ids map to their definitions.
We must also design for versioning since kit schemas evolve
over time to include new types and new slots.
</p>

<!-- /////////////////////////////////////////////////////// -->
<h1 id="checksums">Kit Checksums</h1>
<!-- /////////////////////////////////////////////////////// -->

<p>
Every kit contains zero or more named types.  Each type declares
zero or more slots.  For a given version of a kit, there is a fixed
list of types and their declared slots.  Each slot has a fixed
name, flags, and type.  When a kit is compiled from source into
a kit zip file, the compiler generates a <i>checksum</i> for this fixed
list of types and slots.  The combination of a kit name and checksum
is called a <i>kit part</i>.
</p>

<p id="manifest">
The kit meta-data, checksum, and list of types and slots is included
in the kit file as an XML file called "manifest.xml".  Here is an example manifest file:
</p>

<pre>
&lt;?xml version='1.0'?>
&lt;kitManifest
   name="sysTest"
   checksum="da52f78f"
   version="1.0"
   vendor="Tridium"
   description="Test suite for core language and sys APIs"
   buildHost="BLAZE"
   buildTime="2007-05-17T16:21:08.030-04:00"
>

&lt;type id="0" name="AbstractTestComp" base="sys::Component">
  &lt;slot id="0" name="az" type="bool"/>
  &lt;slot id="1" name="ai" type="int"/>
&lt;/type>

&lt;type id="1" name="TestComp" base="sysTest::AbstractTestComp">
  &lt;slot id="0" name="z1" type="bool"/>
  &lt;slot id="1" name="b1" type="byte"/>
  &lt;slot id="2" name="addF1" type="float" flags="a"/>
&lt;/type>

&lt;type id="2" name="SubTestComp" base="sysTest::TestComp">
  &lt;slot id="0" name="sb" type="byte"/>
  &lt;slot id="1" name="si" type="int"/>
&lt;/type>

&lt;/kitManifest>
</pre>

<p>
The checksum is based only on the kit's types and slots.  The checksum is
not based on variable meta-data such as the kit's version number.  This
means that multiple versions of the same kit might share the same checksum
if no types or slots have been modified.  Don't confuse version with
checksum.  Version represents a revision of the whole kit including its
code, algorithms, and when it was built.  Checksum represents a revision
of the declared types and slots.
</p>

<!-- /////////////////////////////////////////////////////// -->
<h1 id="kitDb">Kit Database</h1>
<!-- /////////////////////////////////////////////////////// -->

<p>
Within a Sedona Framework installation we store all the local copies of
kits with the file pattern:
</p>

<pre>
{home}/kits/{kit}/{kit}-{checksum}-{version}.kit
{home}/kits/control/control-cdf5f0f0-1.0.29.kit
</pre>

<p>
We call this directory the <i>kit database</i>.  It can store
multiple concurrent versions of each kit.  The <code>sedona.kit.*</code>
APIs are used to work with the kit database.
</p>

<!-- /////////////////////////////////////////////////////// -->
<h1 id="manifestDb">Manifest Database</h1>
<!-- /////////////////////////////////////////////////////// -->

<p>
Kits always contain the manifest information we need when working
with schema.  However, to interface with the kit we don't need the full
kit file, only the XML manifest inside of it.  So in addition to the kit
database, we also store a manifest database with the file pattern:
</p>

<pre>
{home}/manifests/{kit}/{kit}-{checksum}.xml
{home}/manifests/control/control-cdf5f0f0.xml
</pre>

<p>
By pulling the manifests out into a separate database, we don't
require the full kit file to work with the kit's types.  This is
typically more efficient, and it allows a manufacturer to only
publish the manifest versus the whole kit file.
</p>

<p>
The <code>sedona.manifest.*</code> APIs are used to work with manifests
and the manifest database via the Java toolkit.  The <code>KitManifest</code>
class represents the information stored a kit manifest file and provides
methods for encoding and decoding from XML.  The <code>ManifestDb</code>
class is used to load and save <code>KitManifests</code> to the file
system.
</p>

<!-- /////////////////////////////////////////////////////// -->
<h1 id="schemas">Schemas</h1>
<!-- /////////////////////////////////////////////////////// -->

<p>
A Sedona Framework runtime image or application is composed of multiple
kits.  A specific list of kit parts (kits at a specific checksum
revision) is called a <i>schema</i>.  Matching schemas guarantee
binary compatibility.
</p>

<p>
Only when a kit manifest is pulled into a specific schema do we
know information such as kit id and slot id.  For example the kit
id for "control" might be 3 in one schema, and 5 in another schema
that has a different list of kit parts.  Slot ids might also change
for a given kit part across schemas depending on the slots inherited
from base types.
</p>

<p>
The <code>sedona.*</code> APIs are used to work with schemas via
the Java toolkit.  Schemas are built with the <code>sedona.Schema</code>
class from a list of <code>KitParts</code> that are resolved against
the manifest database.  Assuming all the kit parts can be resolved to
kit manifests, we can build a complete representation of the schema
including the full list of kits, types, and slots along with
their respective ids.  The <code>Schema</code> is then used
to work with binary formats such as ".sab" files and Sox messages.
</p>

<!-- /////////////////////////////////////////////////////// -->
<h1 id="resolvingManifests">Resolving Manifests</h1>
<!-- /////////////////////////////////////////////////////// -->

<p>
The recommended rules for resolving a given kit name and
checksum to a manifest:
</p>

<ol>
<li>Check the local manifest database first, if found use it;</li>
<li>Check the local kit database, if found then copy the manifest
to the local manifest database for the next time around;</li>
<li>Download the manifest from Internet via sedonadev.org to the
local manifest database;</li>
</ol>

<p>
These steps are automatically implemented by the Sedona <code>ManifestDb</code>
API.
</p>

<!-- /////////////////////////////////////////////////////// -->
<h2 id="mfServer">Manifest Server</h2>
<!-- /////////////////////////////////////////////////////// -->

<p>
Beginning with Sedona 1.2, the Sox client supports retrieving
manifest files from the remote Sedona device, using a special
filename prefix called a "scheme" to tell the device where to
find the file in its local file system.  This allows the manifest 
retrieval to be accomplished using the regular Sox file transfer
protocol.  
To make this feature work on a new Sedona platform, the following 
things must be true:
</p>

<ul>
  <li>The "<b>m:</b>" scheme must be implemented on the remote Sedona device 
  (see below).</li>
  <li>The required manifest file(s) must already be stored on the device.</li>
  <li>The <code>sedonadev.autodownload</code> property in sedona.properties 
  must be set to false (or omitted entirely).</li>
</ul>

<p>
A <i>scheme</i> is simply a prefix to the filename, such as "m:", that is 
translated behind the scenes into a local path where the file should be located.
There are two ways to implement a scheme in Sedona:  
</p>

<ol>
  <li>It can be implemented entirely at the native level, encapsulated in the
  appropriate <code>sys::FileStore natives.</code></li>
  <li>It can be implemented at the Sedona level using a platform-specific
   FileStore subclass.</li>
</ol>

<p>
If it is implemented at the native level, then at the Sedona level the device
treats the prefix as part of the actual filename.  The appropriate FileStore
native methods strip off the prefix and substitute the corresponding path.
The resulting full path to the file is then passed to the local file system
just like any other file transfer request.
</p>

<p>
If it is implemented using a FileStore subclass, then the FileStore subclass
should override the <code>accept()</code> method such that it returns true if 
the filename begins with the desired prefix.  
Then the <code>open()</code> method can be overridden to strip off the scheme 
prefix and substitute the desired path, or the FileStore subclass may have an 
additional native method that provides the appropriate path for all files in 
that scheme.
</p>


<!-- /////////////////////////////////////////////////////// -->
<h1 id="kitsVsManifests">Kits versus Manifests</h1>
<!-- /////////////////////////////////////////////////////// -->

<p>
So when do you need a kit and when do you only need a manifest?
This table helps summarize the differences:
</p>

<table>

<tr>
  <th></th>
  <th>Encapsulates</th>
  <th>Versioned By</th>
  <th>Uses</th>
</tr>

<tr>
  <th>Manifest</th>
  <td>type and slot schema</td>
  <td>checksum</td>
  <td>sax, sab, and sox</td>
</tr>

<tr>
  <th>Kit</th>
  <td>code</td>
  <td>version number</td>
  <td>compiling dependencies and scode images</td>
</tr>

</table>

<p>
For example when working with an application file or Sox, only
the type schemas are needed.  No knowledge of the internal code
is required.  However when compiling, you need the full kit that
contains the actual code.
So a manifest is somewhat analogous to a C header
file, which declares function prototypes but does not contain any
code for the functions.
</p>

<p>
Manifests are versioned with a checksum each time a type or
slot definition is modified.  Kits are versioned with a version
number typically whenever code is modified.
</p>

<!-- /////////////////////////////////////////////////////// -->
<h1 id="review">Review</h1>
<!-- /////////////////////////////////////////////////////// -->

<p>
To summarize the schema pipeline:
</p>

<ol>
  <li><b>Checksum</b>: Generated by the compiler when compiling a kit
  file from source, the checksum is based on the declared types
and slots in the kit.</li>

<li><b>Kit Part</b>: The combination of kit name and kit
checksum that uniquely identifies a kit for a specific schema
revision.</li>

<li><b>Kit Manifest</b>: A file containing a kit's checksum
and type definitions, stored as a zip archive entry named "manifest.xml".
</li>

<li><b>Kit Database</b>: A database of all local kit versions,
created and maintained by the Sedona Framework Java toolkit.  </li>

<li><b>Manifest Database</b>: A database of all the different kit manifests that
have been accumulated, created and maintained by the Sedona Framework Java toolkit.
These manifests are XML files keyed by kit name and checksum.</li>

<li><b>Schema</b>: A list of kit parts aggregated by the Sedona Framework Java toolkit.
A schema defines the full meta-data required to work with binary format
entities with matching schemas.
Each Sedona Framework runtime and application file has a single, fixed schema.
The Java toolkit can model multiple
schemas simultaneously via the <code>sedona.Schema</code> API.</li>

</ol>

<!-- TOC-FOOTER-START -->
<!-- Auto-generated by sedonac -->
</div>
<div class='nav'>
  <a href='index.html'>Index</a>
 | <a href='kits.html'>Prev</a>
 | <a href='platDef.html'>Next</a>
</div>
<div class='copyright'><script type='text/javascript'>document.write("Copyright &#169; " + new Date().getFullYear() + " Tridium, Inc.")</script></div>
</body>
<!-- TOC-FOOTER-END -->

</html>







